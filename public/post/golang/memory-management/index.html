<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Golang内存管理 - CctoctoFX</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="CctoctoFX" /><meta name="description" content="设计原则 现在我们来看 Go 中另一重要的关键组件：内存分配器。 Go 的内存分配器基于 Thread-Cache Malloc (tcmalloc) ，tcmalloc 为每个线程实现了一个本地缓存， 区分了小对象" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.76.4 with theme even" />


<link rel="canonical" href="http://localhost:2000/post/golang/memory-management/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.2e81bbed97b8b282c1aeb57488cc71c8d8c8ec559f3931531bd396bf31e0d4dd.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Golang内存管理" />
<meta property="og:description" content="设计原则 现在我们来看 Go 中另一重要的关键组件：内存分配器。 Go 的内存分配器基于 Thread-Cache Malloc (tcmalloc) ，tcmalloc 为每个线程实现了一个本地缓存， 区分了小对象" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:2000/post/golang/memory-management/" />
<meta property="article:published_time" content="2020-12-02T11:22:18+08:00" />
<meta property="article:modified_time" content="2020-12-02T11:22:18+08:00" />
<meta itemprop="name" content="Golang内存管理">
<meta itemprop="description" content="设计原则 现在我们来看 Go 中另一重要的关键组件：内存分配器。 Go 的内存分配器基于 Thread-Cache Malloc (tcmalloc) ，tcmalloc 为每个线程实现了一个本地缓存， 区分了小对象">
<meta itemprop="datePublished" content="2020-12-02T11:22:18+08:00" />
<meta itemprop="dateModified" content="2020-12-02T11:22:18+08:00" />
<meta itemprop="wordCount" content="3291">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Golang内存管理"/>
<meta name="twitter:description" content="设计原则 现在我们来看 Go 中另一重要的关键组件：内存分配器。 Go 的内存分配器基于 Thread-Cache Malloc (tcmalloc) ，tcmalloc 为每个线程实现了一个本地缓存， 区分了小对象"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">CctoctoFX</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">CctoctoFX</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Golang内存管理</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-12-02 </span>
        
          <span class="more-meta"> 3291 words </span>
          <span class="more-meta"> 7 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#设计原则">设计原则</a>
      <ul>
        <li><a href="#主要结构">主要结构</a>
          <ul>
            <li><a href="#arena">Arena</a></li>
            <li><a href="#mspan">mspan</a></li>
            <li><a href="#mcache">mcache</a></li>
            <li><a href="#mcentral">mcentral</a></li>
            <li><a href="#mheap">mheap</a></li>
          </ul>
        </li>
        <li><a href="#分配概览">分配概览</a>
          <ul>
            <li><a href="#分配入口">分配入口</a></li>
            <li><a href="#小对象分配">小对象分配</a></li>
            <li><a href="#微对象分配">微对象分配</a></li>
            <li><a href="#大对象分配">大对象分配</a></li>
          </ul>
        </li>
        <li><a href="#小结">小结</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="设计原则">设计原则</h1>
<p>现在我们来看 Go 中另一重要的关键组件：内存分配器。</p>
<p>Go 的内存分配器基于 Thread-Cache Malloc (tcmalloc) ，tcmalloc 为每个线程实现了一个本地缓存， 区分了小对象（小于 32kb）和大对象分配两种分配类型，其管理的内存单元称为 span。</p>
<p>我们不再介绍更多 tcmalloc 的具体细节，因为 Go 的内存分配器与 tcmalloc 存在一定差异。 这个差异来源于 Go 语言被设计为没有显式的内存分配与释放， 完全依靠编译器与运行时的配合来自动处理，因此也就造就了内存分配器、垃圾回收器两大组件。</p>
<p>我们知道，在计算机领域中，无外乎时间换空间、空间换时间。统一管理内存会提前分配或一次性释放一大块内存， 进而减少与操作系统沟通造成的开销，进而提高程序的运行性能。 支持内存管理另一个优势就是能够更好的支持垃圾回收，这一点我们留到垃圾回收器的章节中进行讨论。</p>
<h2 id="主要结构">主要结构</h2>
<p>Go 的内存分配器主要包含以下几个核心组件：</p>
<ul>
<li>heapArena: 保留整个虚拟地址空间</li>
<li>mheap：分配的堆，在页大小为 8KB 的粒度上进行管理</li>
<li>mspan：是 mheap 上管理的一连串的页</li>
<li>mcentral：收集了给定大小等级的所有 span</li>
<li>mcache：为 per-P 的缓存。</li>
</ul>
<p>其中页是向操作系统申请内存的最小单位，目前设计为 8KB。</p>
<p>每一个结构虽然不都像是调度器 M/P/G 结构那样的大部头，但初次阅读这些结构时想要理清他们之间的关系还是比较麻烦的。 传统意义上的栈被 Go 的运行时霸占，不开放给用户态代码；而传统意义上的堆内存，又被 Go 运行时划分为了两个部分， 一个是 Go 运行时自身所需的堆内存，即堆外内存；另一部分则用于 Go 用户态代码所使用的堆内存，也叫做 Go 堆。 Go 堆负责了用户态对象的存放以及 goroutine 的执行栈。</p>
<h3 id="arena">Arena</h3>
<h4 id="heaparena">heapArena</h4>
<p>Go 堆被视为由多个 arena 组成，每个 arena 在 64 位机器上为 64MB，且起始地址与 arena 的大小对齐， 所有的 arena 覆盖了整个 Go 堆的地址空间。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">pageSize</span>             <span class="p">=</span> <span class="mi">8192</span>                       <span class="c1">// 8KB
</span><span class="c1"></span>	<span class="nx">heapArenaBytes</span>       <span class="p">=</span> <span class="mi">67108864</span>                   <span class="c1">// 64MB
</span><span class="c1"></span>	<span class="nx">heapArenaBitmapBytes</span> <span class="p">=</span> <span class="nx">heapArenaBytes</span> <span class="o">/</span> <span class="mi">32</span>        <span class="c1">// 2097152
</span><span class="c1"></span>	<span class="nx">pagesPerArena</span>        <span class="p">=</span> <span class="nx">heapArenaBytes</span> <span class="o">/</span> <span class="nx">pageSize</span>  <span class="c1">// 8192
</span><span class="c1"></span><span class="p">)</span>

<span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">heapArena</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">bitmap</span>     <span class="p">[</span><span class="nx">heapArenaBitmapBytes</span><span class="p">]</span><span class="kt">byte</span>
	<span class="nx">spans</span>      <span class="p">[</span><span class="nx">pagesPerArena</span><span class="p">]</span><span class="o">*</span><span class="nx">mspan</span>
	<span class="nx">pageInUse</span>  <span class="p">[</span><span class="nx">pagesPerArena</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>
	<span class="nx">pageMarks</span>  <span class="p">[</span><span class="nx">pagesPerArena</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>
	<span class="nx">zeroedBase</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="arenahint">arenaHint</h4>
<p>结构比较简单，是 arenaHint 链表的节点结构，保存了 arena 的起始地址、是否为最后一个 arena，以及下一个 arenaHint 指针。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">arenaHint</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">addr</span> <span class="kt">uintptr</span>
	<span class="nx">down</span> <span class="kt">bool</span>
	<span class="nx">next</span> <span class="o">*</span><span class="nx">arenaHint</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="mspan">mspan</h3>
<p>然而管理 arena 如此粒度的内存并不符合实践，相反，所有的堆对象都通过 span 按照预先设定好的 大小等级分别分配，小于 32KB 的小对象则分配在固定大小等级的 span 上，否则直接从 mheap 上进行分配。</p>
<p><code>mspan</code> 是相同大小等级的 span 的双向链表的一个节点，每个节点还记录了自己的起始地址、 指向的 span 中页的数量。它要么位于</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">mspan</span> <span class="kd">struct</span> <span class="p">{</span> <span class="c1">// 双向链表
</span><span class="c1"></span>	<span class="nx">next</span> <span class="o">*</span><span class="nx">mspan</span>     <span class="c1">// 链表中的下一个 span，如果为空则为 nil
</span><span class="c1"></span>	<span class="nx">prev</span> <span class="o">*</span><span class="nx">mspan</span>     <span class="c1">// 链表中的前一个 span，如果为空则为 nil
</span><span class="c1"></span>	<span class="o">...</span>
	<span class="nx">startAddr</span>      <span class="kt">uintptr</span> <span class="c1">// span 的第一个字节的地址，即 s.base()
</span><span class="c1"></span>	<span class="nx">npages</span>         <span class="kt">uintptr</span> <span class="c1">// 一个 span 中的 page 数量
</span><span class="c1"></span>	<span class="nx">manualFreeList</span> <span class="nx">gclinkptr</span> <span class="c1">// mSpanManual span 的释放对象链表
</span><span class="c1"></span>	<span class="o">...</span>
	<span class="nx">freeindex</span>  <span class="kt">uintptr</span>
	<span class="nx">nelems</span>     <span class="kt">uintptr</span> <span class="c1">// span 中对象的数量
</span><span class="c1"></span>	<span class="nx">allocCache</span> <span class="kt">uint64</span>
	<span class="nx">allocBits</span>  <span class="o">*</span><span class="nx">gcBits</span>
	<span class="o">...</span>
	<span class="nx">allocCount</span>  <span class="kt">uint16</span>     <span class="c1">// 分配对象的数量
</span><span class="c1"></span>	<span class="nx">spanclass</span>   <span class="nx">spanClass</span>  <span class="c1">// 大小等级与 noscan (uint8)
</span><span class="c1"></span>	<span class="nx">incache</span>     <span class="kt">bool</span>       <span class="c1">// 是否被 mcache 使用
</span><span class="c1"></span>	<span class="nx">state</span>       <span class="nx">mSpanState</span> <span class="c1">// mspaninuse 等等信息
</span><span class="c1"></span>	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="mcache">mcache</h3>
<p>是一个 per-P 的缓存，它是一个包含不同大小等级的 span 链表的数组，其中 mcache.alloc 的每一个数组元素 都是某一个特定大小的 mspan 的链表头指针。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">mcache</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nx">tiny</span>             <span class="kt">uintptr</span>
	<span class="nx">tinyoffset</span>       <span class="kt">uintptr</span>
	<span class="nx">local_tinyallocs</span> <span class="kt">uintptr</span>
	<span class="nx">alloc</span>            <span class="p">[</span><span class="nx">numSpanClasses</span><span class="p">]</span><span class="o">*</span><span class="nx">mspan</span> <span class="c1">// 用来分配的 spans，由 spanClass 索引
</span><span class="c1"></span>	<span class="nx">stackcache</span>       <span class="p">[</span><span class="nx">_NumStackOrders</span><span class="p">]</span><span class="nx">stackfreelist</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当 mcache 中 span 的数量不够使用时，会向 mcentral 的 nonempty 列表中获得新的 span。</p>
<h3 id="mcentral">mcentral</h3>
<p>mcentral</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">mcentral</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span>      <span class="nx">mutex</span>
	<span class="nx">spanclass</span> <span class="nx">spanClass</span>
	<span class="nx">nonempty</span>  <span class="nx">mSpanList</span> <span class="c1">// 带有自由对象的 span 列表，即非空闲列表
</span><span class="c1"></span>	<span class="nx">empty</span>     <span class="nx">mSpanList</span> <span class="c1">// 没有自由对象的 span 列表（或缓存在 mcache 中）
</span><span class="c1"></span>	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当 mcentral 中 nonempty 列表中也没有可分配的 span 时，则会向 mheap 提出请求，从而获得 新的 span，并进而交给 mcache。</p>
<h3 id="mheap">mheap</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">mheap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span>           <span class="nx">mutex</span>
	<span class="nx">pages</span>          <span class="nx">pageAlloc</span>
	<span class="o">...</span>
	<span class="nx">allspans</span>       <span class="p">[]</span><span class="o">*</span><span class="nx">mspan</span> <span class="c1">// 所有 spans 从这里分配出去
</span><span class="c1"></span>	<span class="nx">scavengeGoal</span>   <span class="kt">uint64</span>
	<span class="nx">reclaimIndex</span>   <span class="kt">uint64</span>
	<span class="nx">reclaimCredit</span>  <span class="kt">uintptr</span>
	<span class="nx">arenas</span>         <span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">arenaL1Bits</span><span class="p">]</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">arenaL2Bits</span><span class="p">]</span><span class="o">*</span><span class="nx">heapArena</span>
	<span class="nx">heapArenaAlloc</span> <span class="nx">linearAlloc</span>
	<span class="nx">arenaHints</span>     <span class="o">*</span><span class="nx">arenaHint</span>
	<span class="nx">arena</span>          <span class="nx">linearAlloc</span>
	<span class="nx">allArenas</span>      <span class="p">[]</span><span class="nx">arenaIdx</span>
	<span class="nx">curArena</span>       <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">base</span><span class="p">,</span> <span class="nx">end</span> <span class="kt">uintptr</span>
	<span class="p">}</span>
	<span class="nx">central</span>       <span class="p">[</span><span class="nx">numSpanClasses</span><span class="p">]</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">mcentral</span> <span class="nx">mcentral</span>
		<span class="nx">pad</span>      <span class="p">[</span><span class="nx">cpu</span><span class="p">.</span><span class="nx">CacheLinePadSize</span> <span class="o">-</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">mcentral</span><span class="p">{})</span><span class="o">%</span><span class="nx">cpu</span><span class="p">.</span><span class="nx">CacheLinePadSize</span><span class="p">]</span><span class="kt">byte</span>
	<span class="p">}</span>
	<span class="o">...</span>

	<span class="c1">// 各种分配器
</span><span class="c1"></span>	<span class="nx">spanalloc</span>             <span class="nx">fixalloc</span> <span class="c1">// span* 分配器
</span><span class="c1"></span>	<span class="nx">cachealloc</span>            <span class="nx">fixalloc</span> <span class="c1">// mcache* 分配器
</span><span class="c1"></span>	<span class="nx">treapalloc</span>            <span class="nx">fixalloc</span> <span class="c1">// treapNodes* 分配器，用于大对象
</span><span class="c1"></span>	<span class="nx">specialfinalizeralloc</span> <span class="nx">fixalloc</span> <span class="c1">// specialfinalizer* 分配器
</span><span class="c1"></span>	<span class="nx">specialprofilealloc</span>   <span class="nx">fixalloc</span> <span class="c1">// specialprofile* 分配器
</span><span class="c1"></span>	<span class="nx">speciallock</span>           <span class="nx">mutex</span>    <span class="c1">// 特殊记录分配器的锁
</span><span class="c1"></span>	<span class="nx">arenaHintAlloc</span>        <span class="nx">fixalloc</span> <span class="c1">// arenaHints 分配器
</span><span class="c1"></span>	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="分配概览">分配概览</h2>
<p>在分析具体的分配过程之前，我们需要搞清楚究竟什么时候会发生分配。</p>
<p>Go 程序的执行是基于 goroutine 的，goroutine 和传统意义上的程序一样，也有栈和堆的概念。只不过 Go 的运行时帮我们屏蔽掉了这两个概念，只在运行时内部区分并分别对应：goroutine 执行栈以及 Go 堆。</p>
<p>goroutine 的执行栈与传统意义上的栈一样，当函数返回时，在栈上就会被回收，栈中的对象都会被回收，从而 无需 GC 的标记；而堆则麻烦一些，由于 Go 支持垃圾回收，只要对象生存在堆上，Go 的运行时 GC 就会在 后台将对应的内存进行标记从而能够在垃圾回收的时候将对应的内存回收，进而增加了开销。</p>
<p>下面这个程序给出了四种情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">type</span> <span class="nx">smallobj</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">]</span><span class="kt">byte</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">largeobj</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">]</span><span class="kt">byte</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">f1</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">x</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">f2</span><span class="p">()</span> <span class="o">*</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">y</span> <span class="o">:=</span> <span class="mi">2</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">y</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">f3</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">large</span> <span class="o">:=</span> <span class="nx">largeobj</span><span class="p">{}</span>
	<span class="nb">println</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">large</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">f4</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">small</span> <span class="o">:=</span> <span class="nx">smallobj</span><span class="p">{}</span>
	<span class="nb">print</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">small</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">x</span> <span class="o">:=</span> <span class="nf">f1</span><span class="p">()</span>
	<span class="nx">y</span> <span class="o">:=</span> <span class="nf">f2</span><span class="p">()</span>
	<span class="nf">f3</span><span class="p">()</span>
	<span class="nf">f4</span><span class="p">()</span>
	<span class="nb">println</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们使用 <code>-gcflags &quot;-N -l -m&quot;</code> 编译这段代码能够禁用编译器与内联优化并进行逃逸分析：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="err">#</span> <span class="nx">alloc</span><span class="p">.</span><span class="k">go</span>
<span class="err">#</span> <span class="k">go</span> <span class="nx">build</span> <span class="o">-</span><span class="nx">gcflags</span> <span class="s">&#34;-N -l -m&#34;</span> <span class="o">-</span><span class="nx">ldflags</span><span class="p">=</span><span class="o">-</span><span class="nx">compressdwarf</span><span class="p">=</span><span class="kc">false</span> <span class="o">-</span><span class="nx">o</span> <span class="nx">alloc</span><span class="p">.</span><span class="nx">out</span> <span class="nx">alloc</span><span class="p">.</span><span class="k">go</span>
<span class="err">#</span> <span class="nx">command</span><span class="o">-</span><span class="nx">line</span><span class="o">-</span><span class="nx">arguments</span>
<span class="p">.</span><span class="o">/</span><span class="nx">alloc</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">18</span><span class="p">:</span><span class="mi">9</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">y</span> <span class="nx">escapes</span> <span class="nx">to</span> <span class="nx">heap</span>
<span class="p">.</span><span class="o">/</span><span class="nx">alloc</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">17</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span> <span class="nx">moved</span> <span class="nx">to</span> <span class="nx">heap</span><span class="p">:</span> <span class="nx">y</span>
<span class="p">.</span><span class="o">/</span><span class="nx">alloc</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">22</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span> <span class="nx">moved</span> <span class="nx">to</span> <span class="nx">heap</span><span class="p">:</span> <span class="nx">large</span>
<span class="p">.</span><span class="o">/</span><span class="nx">alloc</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">23</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span> <span class="nx">f3</span> <span class="o">&amp;</span><span class="nx">large</span> <span class="nx">does</span> <span class="nx">not</span> <span class="nx">escape</span>
<span class="p">.</span><span class="o">/</span><span class="nx">alloc</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">28</span><span class="p">:</span><span class="mi">8</span><span class="p">:</span> <span class="nx">f4</span> <span class="o">&amp;</span><span class="nx">small</span> <span class="nx">does</span> <span class="nx">not</span> <span class="nx">escape</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>情况1: <code>f1</code> 中 <code>x</code> 的变量被返回，没有发生逃逸；</li>
<li>情况2: <code>f2</code> 中 <code>y</code> 的指针被返回，进而发生了逃逸；</li>
<li>情况3: <code>f3</code> 中 <code>large</code> 无法被一个执行栈装下，即便没有返回，也会直接在堆上分配；</li>
<li>情况4: <code>f4</code> 中 <code>small</code> 对象能够被一个执行栈装下，变量没有返回到栈外，进而没有发生逃逸。</li>
</ul>
<p>如果我们再仔细检查一下他们的汇编：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">TEXT main.f2(SB) /Users/changkun/dev/go-under-the-hood/demo/4-mem/alloc/alloc.go
  ...
  alloc.go:17		0x104e086		488d05939f0000		LEAQ type.*+40256(SB), AX		
  alloc.go:17		0x104e08d		48890424		MOVQ AX, 0(SP)				
  alloc.go:17		0x104e091		e8cabffbff		CALL runtime.newobject(SB)		
  alloc.go:17		0x104e096		488b442408		MOVQ 0x8(SP), AX			
  alloc.go:17		0x104e09b		4889442410		MOVQ AX, 0x10(SP)			
  alloc.go:17		0x104e0a0		48c70002000000		MOVQ $0x2, 0(AX)			
  ...

TEXT main.f3(SB) /Users/changkun/dev/go-under-the-hood/demo/4-mem/alloc/alloc.go
  ...
  alloc.go:22		0x104e0ed		488d05ecf60000		LEAQ type.*+62720(SB), AX		
  alloc.go:22		0x104e0f4		48890424		MOVQ AX, 0(SP)				
  alloc.go:22		0x104e0f8		e863bffbff		CALL runtime.newobject(SB)		
  alloc.go:22		0x104e0fd		488b7c2408		MOVQ 0x8(SP), DI			
  alloc.go:22		0x104e102		48897c2418		MOVQ DI, 0x18(SP)			
  alloc.go:22		0x104e107		b900008000		MOVL $0x800000, CX			
  alloc.go:22		0x104e10c		31c0			XORL AX, AX				
  alloc.go:22		0x104e10e		f348ab			REP; STOSQ AX, ES:0(DI)			
  ...
</code></pre></td></tr></table>
</div>
</div><p>就会发现，对于产生在 Go 堆上分配对象的情况，均调用了运行时的 <code>runtime.newobject</code> 方法。 当然，关键字 <code>new</code> 同样也会被编译器翻译为此函数，这个我们已经在实践中知道了。 所以 <code>runtime.newobject</code> 就是内存分配的核心入口了。</p>
<h3 id="分配入口">分配入口</h3>
<p>单看 <code>runtime.newobject</code> 其实非常简单，他只是简单的调用了 <code>mallocgc</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 创建一个新的对象
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">typ</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nx">typ</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// true 内存清零
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中 <code>_type</code> 为 Go 类型的实现，通过其 <code>size</code> 属性能够获得该类型所需要的大小。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="c1">// 创建大小为零的对象，例如空结构体
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zerobase</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="o">...</span>

	<span class="c1">// 获取当前 g 所在 M 所绑定 P 的 mcache
</span><span class="c1"></span>	<span class="nx">c</span> <span class="o">:=</span> <span class="nf">gomcache</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">x</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="nx">noscan</span> <span class="o">:=</span> <span class="nx">typ</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">kind</span><span class="o">&amp;</span><span class="nx">kindNoPointers</span> <span class="o">!=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">maxSmallSize</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">noscan</span> <span class="o">&amp;&amp;</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">maxTinySize</span> <span class="p">{</span>
			<span class="c1">// 微对象分配
</span><span class="c1"></span>			<span class="o">...</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 小对象分配
</span><span class="c1"></span>			<span class="o">...</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 大对象分配
</span><span class="c1"></span>		<span class="o">...</span>
	<span class="p">}</span>
	<span class="o">...</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="o">...</span>
	<span class="k">return</span> <span class="nx">x</span>
</code></pre></td></tr></table>
</div>
</div><p>在分配过程中，我们会发现需要持有 M 才可进行分配，这是因为分配不仅可能涉及 mcache，还需要将正在分配的 M 标记为 <code>mallocing</code>，用于记录当前 M 的分配状态。</p>
<h3 id="小对象分配">小对象分配</h3>
<p>当对一个小对象（&lt;32KB）分配内存时，会将该对象所需的内存大小调整到某个能够容纳该对象的大小等级（size class）， 并查看 mcache 中对应等级的 mspan，通过扫描 mspan 的 <code>freeindex</code> 来确定是否能够进行分配。</p>
<p>当没有可分配的 mspan 时，会从 mcentral 中获取一个所需大小空间的新的 mspan，从 mcentral 中分配会对其进行加锁， 但一次性获取整个 span 的过程均摊了对 mcentral 加锁的成本。</p>
<p>如果 mcentral 的 mspan 也为空时，则它也会发生增长，从而从 mheap 中获取一连串的页，作为一个新的 mspan 进行提供。 而如果 mheap 仍然为空，或者没有足够大的对象来进行分配时，则会从操作系统中分配一组新的页（至少 1MB）， 从而均摊与操作系统沟通的成本。</p>
<h3 id="微对象分配">微对象分配</h3>
<p>对于过小的微对象（&lt;16B），它们的分配过程与小对象的分配过程基本类似，但是是直接存储在 mcache 上，并由其以 16B 的块大小直接进行管理和释放。</p>
<h3 id="大对象分配">大对象分配</h3>
<p>大对象分配非常粗暴，不与 mcache 和 mcentral 沟通，直接绕过并通过 mheap 进行分配。</p>
<h2 id="小结">小结</h2>
<p><img src="https://golang.design/under-the-hood/assets/mem-struct.png" alt="mem_structure"></p>
<p>该图展示了所有结构的关系。</p>
<p>heap 最中间的灰色区域 arena 覆盖了 Go 程序的整个虚拟内存， 每个 arena 包括一段 bitmap 和一段指向连续 span 的指针； 每个 span 由一串连续的页组成；每个 arena 的起始位置通过 arenaHint 进行记录。</p>
<p>分配的顺序从右向左，代价也就越来越大。 小对象和微对象优先从白色区域 per-P 的 mcache 分配 span，这个过程不需要加锁（白色）； 若失败则会从 mheap 持有的 mcentral 加锁获得新的 span，这个过程需要加锁，但只是局部（灰色）； 若仍失败则会从右侧的 free 或 scav 进行分配，这个过程需要对整个 heap 进行加锁，代价最大（黑色）。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">CctoctoFX</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2020-12-02
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/golang/bdd-testing-framework/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">BDD: Ginkgo测试框架</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/golang/golang-escape-analysis/">
            <span class="next-text nav-default">Golang逃逸分析</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="derios1230@email.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/pillumina" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/fang-xian-20" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="http://localhost:2000/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>CctoctoFX</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>








</body>
</html>
