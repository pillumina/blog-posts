<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Docker Fundamentals: Namespace - CctoctoFX</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="CctoctoFX" /><meta name="description" content="容器技术出现已经很久，只不过Docker容器平台的出现它变火了。Docker是第一个让容器能在不同机器之间移植的系统，它简化了打包应用的流程" /><meta name="keywords" content="docker, cloud-computing" />






<meta name="generator" content="Hugo 0.76.4 with theme even" />


<link rel="canonical" href="http://localhost:2000/post/cloud-computing/docker-namespace/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.2e81bbed97b8b282c1aeb57488cc71c8d8c8ec559f3931531bd396bf31e0d4dd.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Docker Fundamentals: Namespace" />
<meta property="og:description" content="容器技术出现已经很久，只不过Docker容器平台的出现它变火了。Docker是第一个让容器能在不同机器之间移植的系统，它简化了打包应用的流程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:2000/post/cloud-computing/docker-namespace/" />
<meta property="article:published_time" content="2021-04-01T11:22:18+08:00" />
<meta property="article:modified_time" content="2021-04-01T11:22:18+08:00" />
<meta itemprop="name" content="Docker Fundamentals: Namespace">
<meta itemprop="description" content="容器技术出现已经很久，只不过Docker容器平台的出现它变火了。Docker是第一个让容器能在不同机器之间移植的系统，它简化了打包应用的流程">
<meta itemprop="datePublished" content="2021-04-01T11:22:18+08:00" />
<meta itemprop="dateModified" content="2021-04-01T11:22:18+08:00" />
<meta itemprop="wordCount" content="7723">



<meta itemprop="keywords" content="docker,cloud-computing," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Docker Fundamentals: Namespace"/>
<meta name="twitter:description" content="容器技术出现已经很久，只不过Docker容器平台的出现它变火了。Docker是第一个让容器能在不同机器之间移植的系统，它简化了打包应用的流程"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">CctoctoFX</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">CctoctoFX</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Docker Fundamentals: Namespace</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-04-01 </span>
        <div class="post-category">
            <a href="/categories/docker/"> docker </a>
            <a href="/categories/cloud-computing/"> cloud-computing </a>
            </div>
          <span class="more-meta"> 7723 words </span>
          <span class="more-meta"> 16 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#参考">参考</a></li>
        <li><a href="#什么是namespace">什么是Namespace</a></li>
        <li><a href="#uts-namespace">UTS Namespace</a></li>
        <li><a href="#ipc-namespace">IPC Namespace</a></li>
        <li><a href="#pid-namespace">PID Namespace</a></li>
        <li><a href="#mount-namespace">Mount Namespace</a></li>
        <li><a href="#docker的mount-namespace">Docker的Mount Namespace</a></li>
        <li><a href="#user-namespace">User Namespace</a></li>
        <li><a href="#network-namespace">Network Namespace</a></li>
        <li><a href="#namespace文件">Namespace文件</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>容器技术出现已经很久，只不过Docker容器平台的出现它变火了。Docker是第一个让容器能在不同机器之间移植的系统，它简化了打包应用的流程，也简化了打包应用的库和各种依赖。思考下整个OS的file system能直接被打包成一个简单的可移植的包，一开始的时候概念上还是很有趣的。</p>
<p>有时候我认为自己的阅读比较碎片化(<del>short-term memory越来越少</del>)，所以我想把之前学习容器知识的一些基础技术再整理出来，也算是给自己学习的反馈。这个基础系列从Linux Namespace开始，后续会陆续介绍比如cgroup、aufs、devicemapper等技术。</p>
<h2 id="参考">参考</h2>
<p><a href="https://lwn.net/Articles/531114/">Namespace in operation</a></p>
<p><a href="https://man7.org/linux/man-pages/man7/namespaces.7.html">Linux namespace man page</a></p>
<p><a href="https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/">Introduction to linux namespace</a></p>
<h2 id="什么是namespace">什么是Namespace</h2>
<p>简单来说，linux namespace是Linux提供的一种内核级别环境隔离的方法。在早期的Unix中，提供了一种叫做chroot的系统调用：通过修改root目录把用户关到一个特定的目录下面。这种就是简单的隔离方式，也就是chroot内部的file system无法访问外部的内容。Linux Namespace在此基础之上，提供了对UTS、IPC、mount、network、PID、User等隔离机制。</p>
<p>这里可以简单举例，比如Linux的超级父进程的PID为1，如果我们可以把用户的进程空间关到某个进程分支之下，并且像chroot那样能够让下面的进程看到那个超级父进程的PID为1，而不同PID Namespace中的进程无法看到彼此，这样就能达到进程隔离。</p>
<p>Linux Namespace有以下的种类，供给后续参考（刚看有个印象就行）：</p>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">系统调用参数</th>
<th style="text-align:left">相关内核版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Mount namespaces</strong></td>
<td style="text-align:left">CLONE_NEWNS</td>
<td style="text-align:left"><a href="http://lwn.net/2001/0301/a/namespaces.php3">Linux 2.4.19</a></td>
</tr>
<tr>
<td style="text-align:left"><strong>UTS namespaces</strong></td>
<td style="text-align:left">CLONE_NEWUTS</td>
<td style="text-align:left"><a href="http://lwn.net/Articles/179345/">Linux 2.6.19</a></td>
</tr>
<tr>
<td style="text-align:left"><strong>IPC namespaces</strong></td>
<td style="text-align:left">CLONE_NEWIPC</td>
<td style="text-align:left"><a href="http://lwn.net/Articles/187274/">Linux 2.6.19</a></td>
</tr>
<tr>
<td style="text-align:left"><strong>PID namespaces</strong></td>
<td style="text-align:left">CLONE_NEWPID</td>
<td style="text-align:left"><a href="http://lwn.net/Articles/259217/">Linux 2.6.24</a></td>
</tr>
<tr>
<td style="text-align:left"><strong>Network namespaces</strong></td>
<td style="text-align:left">CLONE_NEWNET</td>
<td style="text-align:left"><a href="http://lwn.net/Articles/219794/">始于Linux 2.6.24 完成于 Linux 2.6.29</a></td>
</tr>
<tr>
<td style="text-align:left"><strong>User namespaces</strong></td>
<td style="text-align:left">CLONE_NEWUSER</td>
<td style="text-align:left"><a href="http://lwn.net/Articles/528078/">始于 Linux 2.6.23 完成于 Linux 3.8)</a></td>
</tr>
</tbody>
</table>
<p>其主要涉及到三个系统调用：</p>
<ol>
<li><code>clone()</code>： 实现线程的系统调用，用来创建新的线程，并可通过涉及上述参数做到隔离</li>
<li><code>unshare()</code>： 让某一个线程脱离某namespace</li>
<li><code>setns()</code>: 把某一个线程加到某namespace</li>
</ol>
<p>如果读者你想看具体的实例，请自己man一下(关注一下自己的linux虚拟机内核)，或者google一下，我这里贴一个<code>clone()</code>的source code：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#define _GNU_SOURCE
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sched.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cm">/* 定义一个给 clone 用的栈，栈大小1M */</span>
<span class="cp">#define STACK_SIZE (1024 * 1024)
</span><span class="cp"></span><span class="k">static</span> <span class="kt">char</span> <span class="n">container_stack</span><span class="p">[</span><span class="n">STACK_SIZE</span><span class="p">];</span>
<span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">container_args</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#34;/bin/bash&#34;</span><span class="p">,</span>
    <span class="nb">NULL</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">container_main</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Container - inside the container!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="cm">/* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */</span>
    <span class="n">execv</span><span class="p">(</span><span class="n">container_args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">container_args</span><span class="p">);</span> 
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Something&#39;s wrong!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Parent - start a container!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="cm">/* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span>
    <span class="kt">int</span> <span class="n">container_pid</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="n">container_main</span><span class="p">,</span> <span class="n">container_stack</span><span class="o">+</span><span class="n">STACK_SIZE</span><span class="p">,</span> <span class="n">SIGCHLD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="cm">/* 等待子进程结束 */</span>
    <span class="n">waitpid</span><span class="p">(</span><span class="n">container_pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Parent - container stopped!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的程序注释写的比较明白，和pthreads差不多。不过这个程序里，父子进程的进程空间没有什么区别，父进程能访问到的明显子进程也能访问。</p>
<p>我们用几个例子来看看linux的namespace到底是啥样的，运行的虚拟机为<code>ubuntu14.4</code></p>
<h2 id="uts-namespace">UTS Namespace</h2>
<p>这里略去一些头文件和数据结构的定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">container_main</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Container - inside the container!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="n">sethostname</span><span class="p">(</span><span class="s">&#34;container&#34;</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span> <span class="cm">/* 设置hostname */</span>
    <span class="n">execv</span><span class="p">(</span><span class="n">container_args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">container_args</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Something&#39;s wrong!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Parent - start a container!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">container_pid</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="n">container_main</span><span class="p">,</span> <span class="n">container_stack</span><span class="o">+</span><span class="n">STACK_SIZE</span><span class="p">,</span> 
            <span class="n">CLONE_NEWUTS</span> <span class="o">|</span> <span class="n">SIGCHLD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="cm">/*启用CLONE_NEWUTS Namespace隔离 */</span>
    <span class="n">waitpid</span><span class="p">(</span><span class="n">container_pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Parent - container stopped!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>执行上述的c++程序，会发现子进程的hostname变为了container</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">derios@ubuntu:~$ sudo ./uts
Parent - start a container!
Container - inside the container!
root@container:~# hostname
container
root@container:~# uname -n
container
</code></pre></td></tr></table>
</div>
</div><h2 id="ipc-namespace">IPC Namespace</h2>
<p>IPC(Inter-Process Communication)，是Unix/Linux下的一种通信方式。IPC有共享内存、信号量、消息队列等方法。所以如果要隔离我们也要把IPC进行隔离。换句话说，这样可以保证只有在同一个namespace下的进程之间才能互相通信。目前我对IPC的原理没什么研究，查了查资料，IPC需要有个全局的ID，那么如果我们要做隔离，namespace肯定需要对这个全局ID进行隔离，不能和其他namespace中的进程共享。</p>
<p>要启动IPC隔离，我们需要在<code>clone</code>时加上<code>CLONE_NEWPIC</code>的参数:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="n">container_pid</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="n">container_main</span><span class="p">,</span> <span class="n">container_stack</span><span class="o">+</span><span class="n">STACK_SIZE</span><span class="p">,</span> 
            <span class="n">CLONE_NEWUTS</span> <span class="o">|</span> <span class="n">CLONE_NEWIPC</span> <span class="o">|</span> <span class="n">SIGCHLD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>我们先创建一个IPC的queue，下面的全局ID为0：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">derios@ubuntu:~$ ipcmk -Q 
Message queue id: <span class="m">0</span>
derios@ubuntu:~$ ipcs -q
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
0xd0d56eb2 <span class="m">0</span>          hchen      <span class="m">644</span>        <span class="m">0</span>            <span class="m">0</span>
</code></pre></td></tr></table>
</div>
</div><p>如果我们不加<code>CLONE_NEWIPC</code>参数运行程序，我们可以看到在子进程中还是能看到全局的IPC queue：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">derios@ubuntu:~$ sudo ./uts 
Parent - start a container!
Container - inside the container!
root@container:~# ipcs -q
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
0xd0d56eb2 <span class="m">0</span>          hchen      <span class="m">644</span>        <span class="m">0</span>            <span class="m">0</span>
</code></pre></td></tr></table>
</div>
</div><p>如果我们运行加上了<code>CLONE_NEWIPC</code>的程序，可以有如下的结果:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">root@ubuntu:~$ sudo./ipc
Parent - start a container!
Container - inside the container!
root@container:~/linux_namespace# ipcs -q
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
</code></pre></td></tr></table>
</div>
</div><p>可见IPC已经被隔离。</p>
<h2 id="pid-namespace">PID Namespace</h2>
<p>我们继续修改上述的程序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">container_main</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 查看子进程的PID，我们可以看到其输出子进程的 pid 为 1 */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Container [%5d] - inside the container!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
    <span class="n">sethostname</span><span class="p">(</span><span class="s">&#34;container&#34;</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">execv</span><span class="p">(</span><span class="n">container_args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">container_args</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Something&#39;s wrong!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Parent [%5d] - start a container!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
    <span class="cm">/*启用PID namespace - CLONE_NEWPID*/</span>
    <span class="kt">int</span> <span class="n">container_pid</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="n">container_main</span><span class="p">,</span> <span class="n">container_stack</span><span class="o">+</span><span class="n">STACK_SIZE</span><span class="p">,</span> 
            <span class="n">CLONE_NEWUTS</span> <span class="o">|</span> <span class="n">CLONE_NEWPID</span> <span class="o">|</span> <span class="n">SIGCHLD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> 
    <span class="n">waitpid</span><span class="p">(</span><span class="n">container_pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Parent - container stopped!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行看一下，发现子进程的PID为1：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">derios@ubuntu:~$ sudo ./pid
Parent <span class="o">[</span> 3474<span class="o">]</span> - start a container!
Container <span class="o">[</span> 1<span class="o">]</span> - inside the container!
root@container:~# <span class="nb">echo</span> <span class="nv">$$</span>
<span class="m">1</span>
</code></pre></td></tr></table>
</div>
</div><p>这里的1有啥意义，你可能会问。其实在传统UNIX系统中，PID为1的进程地位比较特殊，指代<code>init</code></p>
<p>，作为所有进程的父进程，有非常多的特权（信号屏蔽etc.），此外它还会检查所有进程的状态，而且如果子进程脱离了父进程（父进程没有wait它），那么<code>init</code>会负责回收资源并结束这个子进程。所以，要做到进程空间的隔离，首先要创建pid为1的进程，比如可以像chroot一样，把子进程的pid在容器内变为1。</p>
<p>不过，很奇怪的是，**我们在子进程的shell里执行top, ps等命令，还是可以看到所有的进程。**这意味着隔离并没有完全。因为像ps, top这些命令会读取<code>/proc</code>文件系统，而因为<code>/proc</code>文件系统在父子进程里都是一样的，所以命令的回显也都是一样的。</p>
<p>因此，我们还要做到<strong>对文件系统的隔离</strong>。</p>
<h2 id="mount-namespace">Mount Namespace</h2>
<p>下面的程序，我们在启用mount namespace并在子进程中重新mount了<code>/proc</code>文件系统。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">container_main</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Container [%5d] - inside the container!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
    <span class="n">sethostname</span><span class="p">(</span><span class="s">&#34;container&#34;</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
    <span class="cm">/* 重新mount proc文件系统到 /proc下 */</span>
    <span class="n">system</span><span class="p">(</span><span class="s">&#34;mount -t proc proc /proc&#34;</span><span class="p">);</span>
    <span class="n">execv</span><span class="p">(</span><span class="n">container_args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">container_args</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Something&#39;s wrong!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Parent [%5d] - start a container!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
    <span class="cm">/* 启用Mount Namespace - 增加CLONE_NEWNS参数 */</span>
    <span class="kt">int</span> <span class="n">container_pid</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="n">container_main</span><span class="p">,</span> <span class="n">container_stack</span><span class="o">+</span><span class="n">STACK_SIZE</span><span class="p">,</span> 
            <span class="n">CLONE_NEWUTS</span> <span class="o">|</span> <span class="n">CLONE_NEWPID</span> <span class="o">|</span> <span class="n">CLONE_NEWNS</span> <span class="o">|</span> <span class="n">SIGCHLD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">waitpid</span><span class="p">(</span><span class="n">container_pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Parent - container stopped!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>执行结果如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">derioshen@ubuntu:~$ sudo ./pid.mnt
Parent <span class="o">[</span> 3502<span class="o">]</span> - start a container!
Container <span class="o">[</span>    1<span class="o">]</span> - inside the container!
root@container:~# ps -elf 
F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD
<span class="m">4</span> S root         <span class="m">1</span>     <span class="m">0</span>  <span class="m">0</span>  <span class="m">80</span>   <span class="m">0</span> -  <span class="m">6917</span> <span class="nb">wait</span>   19:55 pts/2    00:00:00 /bin/bash
<span class="m">0</span> R root        <span class="m">14</span>     <span class="m">1</span>  <span class="m">0</span>  <span class="m">80</span>   <span class="m">0</span> -  <span class="m">5671</span> -      19:56 pts/2    00:00:00 ps -elf
</code></pre></td></tr></table>
</div>
</div><p>我们看到只有2个进程了，<code>pid=1</code>的是我们的<code>/bin/bash</code>，同时再看看<code>/proc</code>目录，也变得比较干净:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">root@container:~# ls /proc
<span class="m">1</span>          dma          key-users   net            sysvipc
<span class="m">16</span>         driver       kmsg        pagetypeinfo   timer_list
acpi       execdomains  kpagecount  partitions     timer_stats
asound     fb           kpageflags  sched_debug    tty
buddyinfo  filesystems  loadavg     schedstat      uptime
bus        fs           locks       scsi           version
cgroups    interrupts   mdstat      self           version_signature
cmdline    iomem        meminfo     slabinfo       vmallocinfo
consoles   ioports      misc        softirqs       vmstat
cpuinfo    irq          modules     stat           zoneinfo
crypto     kallsyms     mounts      swaps
devices    kcore        mpt         sys
diskstats  keys         mtrr        sysrq-trigger
</code></pre></td></tr></table>
</div>
</div><p>通过<code>CLONE_NEWNS</code>创建mount namespace以后，父进程会把自己的文件结构复制给子进程。而子进程中新的namespace中所有mount操作都只会影响自身的文件系统，不会对外界产生任何影响，这就做到了严格的隔离。</p>
<p>那么我们是不是还有别的一些文件系统也要mount？答案是肯定的。</p>
<h2 id="docker的mount-namespace">Docker的Mount Namespace</h2>
<p>我们可以简单搞个小的镜像，这种玩法是我google参考来的，模仿docker的mount namespace。</p>
<p>首先，我们需要一个rootfs， 也就是我们需要把我们要做的镜像中的那些命令什么的copy到一个rootfs的目录下，我们模仿Linux构建如下的目录：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">derios@ubuntu:~/rootfs$ ls
bin  dev  etc  home  lib  lib64  mnt  opt  proc  root  run  sbin  sys  tmp  usr  var
</code></pre></td></tr></table>
</div>
</div><p>然后，我们把一些我们需要的命令copy到 rootfs/bin目录中（sh命令必需要copy进去，不然我们无法 chroot ）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">derios@ubuntu:~/rootfs$ ls ./bin ./usr/bin
 
./bin:
bash   chown  gzip      less  mount       netstat  rm     tabs  tee      top       tty
cat    cp     hostname  ln    mountpoint  ping     sed    tac   <span class="nb">test</span>     touch     umount
chgrp  <span class="nb">echo</span>   ip        ls    mv          ps       sh     tail  timeout  tr        uname
chmod  grep   <span class="nb">kill</span>      more  nc          <span class="nb">pwd</span>      sleep  tar   toe      truncate  which

./usr/bin:
awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs
</code></pre></td></tr></table>
</div>
</div><p>注：你可以使用ldd命令把这些命令相关的那些so文件copy到对应的目录：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">derios@ubuntu:~/rootfs/bin$ ldd bash
  linux-vdso.so.1 <span class="o">=</span>&gt;  <span class="o">(</span>0x00007fffd33fc000<span class="o">)</span>
  libtinfo.so.5 <span class="o">=</span>&gt; /lib/x86_64-linux-gnu/libtinfo.so.5 <span class="o">(</span>0x00007f4bd42c2000<span class="o">)</span>
  libdl.so.2 <span class="o">=</span>&gt; /lib/x86_64-linux-gnu/libdl.so.2 <span class="o">(</span>0x00007f4bd40be000<span class="o">)</span>
  libc.so.6 <span class="o">=</span>&gt; /lib/x86_64-linux-gnu/libc.so.6 <span class="o">(</span>0x00007f4bd3cf8000<span class="o">)</span>
  /lib64/ld-linux-x86-64.so.2 <span class="o">(</span>0x00007f4bd4504000<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>下面是我的rootfs中的一些so文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">derios@ubuntu:~/rootfs$ ls ./lib64 ./lib/x86_64-linux-gnu/

./lib64:
ld-linux-x86-64.so.2

./lib/x86_64-linux-gnu/:
libacl.so.1      libmemusage.so         libnss_files-2.19.so    libpython3.4m.so.1
libacl.so.1.1.0  libmount.so.1          libnss_files.so.2       libpython3.4m.so.1.0
libattr.so.1     libmount.so.1.1.0      libnss_hesiod-2.19.so   libresolv-2.19.so
libblkid.so.1    libm.so.6              libnss_hesiod.so.2      libresolv.so.2
libc-2.19.so     libncurses.so.5        libnss_nis-2.19.so      libselinux.so.1
libcap.a         libncurses.so.5.9      libnss_nisplus-2.19.so  libtinfo.so.5
libcap.so        libncursesw.so.5       libnss_nisplus.so.2     libtinfo.so.5.9
libcap.so.2      libncursesw.so.5.9     libnss_nis.so.2         libutil-2.19.so
libcap.so.2.24   libnsl-2.19.so         libpcre.so.3            libutil.so.1
libc.so.6        libnsl.so.1            libprocps.so.3          libuuid.so.1
libdl-2.19.so    libnss_compat-2.19.so  libpthread-2.19.so      libz.so.1
libdl.so.2       libnss_compat.so.2     libpthread.so.0
libgpm.so.2      libnss_dns-2.19.so     libpython2.7.so.1
libm-2.19.so     libnss_dns.so.2        libpython2.7.so.1.0
</code></pre></td></tr></table>
</div>
</div><p>包括这些命令依赖的一些配置文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">derios@ubuntu:~/rootfs$ ls ./etc
bash.bashrc  group  hostname  hosts  ld.so.cache  nsswitch.conf  passwd  profile  
resolv.conf  shadow
</code></pre></td></tr></table>
</div>
</div><p>看到现在你可能比较懵逼，有的比较熟悉os的同学也可能会问：有的配置希望是在容器起动时给他设置的，而不是hard code在镜像中的。比如：/etc/hosts，/etc/hostname，还有DNS的/etc/resolv.conf文件。OK, 那我们在rootfs外面，我们再创建一个conf目录，把这些文件放到这个目录中:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">derios@ubuntu:~$ ls ./conf
hostname     hosts     resolv.conf
</code></pre></td></tr></table>
</div>
</div><p>这样，我们的父进程就可以动态地设置容器需要的这些文件的配置， 然后再把他们mount进容器，这样，容器的镜像中的配置就比较灵活了。</p>
<p>接下来是程序(<del>Google真好</del>)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#define _GNU_SOURCE
</span><span class="cp">#include</span> <span class="cpf">&lt;sys types.h=&#34;&#34;&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys wait.h=&#34;&#34;&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys mount.h=&#34;&#34;&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sched.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define STACK_SIZE (1024 * 1024)
</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">container_stack</span><span class="p">[</span><span class="n">STACK_SIZE</span><span class="p">];</span>
<span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">container_args</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#34;/bin/bash&#34;</span><span class="p">,</span>
    <span class="s">&#34;-l&#34;</span><span class="p">,</span>
    <span class="nb">NULL</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">container_main</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Container [%5d] - inside the container!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>

    <span class="c1">//set hostname
</span><span class="c1"></span>    <span class="n">sethostname</span><span class="p">(</span><span class="s">&#34;container&#34;</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>

    <span class="c1">//remount &#34;/proc&#34; to make sure the &#34;top&#34; and &#34;ps&#34; show container&#39;s information
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">mount</span><span class="p">(</span><span class="s">&#34;proc&#34;</span><span class="p">,</span> <span class="s">&#34;rootfs/proc&#34;</span><span class="p">,</span> <span class="s">&#34;proc&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span><span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;proc&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mount</span><span class="p">(</span><span class="s">&#34;sysfs&#34;</span><span class="p">,</span> <span class="s">&#34;rootfs/sys&#34;</span><span class="p">,</span> <span class="s">&#34;sysfs&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;sys&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mount</span><span class="p">(</span><span class="s">&#34;none&#34;</span><span class="p">,</span> <span class="s">&#34;rootfs/tmp&#34;</span><span class="p">,</span> <span class="s">&#34;tmpfs&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;tmp&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mount</span><span class="p">(</span><span class="s">&#34;udev&#34;</span><span class="p">,</span> <span class="s">&#34;rootfs/dev&#34;</span><span class="p">,</span> <span class="s">&#34;devtmpfs&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;dev&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mount</span><span class="p">(</span><span class="s">&#34;devpts&#34;</span><span class="p">,</span> <span class="s">&#34;rootfs/dev/pts&#34;</span><span class="p">,</span> <span class="s">&#34;devpts&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;dev/pts&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mount</span><span class="p">(</span><span class="s">&#34;shm&#34;</span><span class="p">,</span> <span class="s">&#34;rootfs/dev/shm&#34;</span><span class="p">,</span> <span class="s">&#34;tmpfs&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;dev/shm&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mount</span><span class="p">(</span><span class="s">&#34;tmpfs&#34;</span><span class="p">,</span> <span class="s">&#34;rootfs/run&#34;</span><span class="p">,</span> <span class="s">&#34;tmpfs&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;run&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/* 
</span><span class="cm">     * 模仿Docker的从外向容器里mount相关的配置文件 
</span><span class="cm">     * 你可以查看：/var/lib/docker/containers/&lt;container_id&gt;/目录，
</span><span class="cm">     * 你会看到docker的这些文件的。
</span><span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mount</span><span class="p">(</span><span class="s">&#34;conf/hosts&#34;</span><span class="p">,</span> <span class="s">&#34;rootfs/etc/hosts&#34;</span><span class="p">,</span> <span class="s">&#34;none&#34;</span><span class="p">,</span> <span class="n">MS_BIND</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span> <span class="o">||</span>
          <span class="n">mount</span><span class="p">(</span><span class="s">&#34;conf/hostname&#34;</span><span class="p">,</span> <span class="s">&#34;rootfs/etc/hostname&#34;</span><span class="p">,</span> <span class="s">&#34;none&#34;</span><span class="p">,</span> <span class="n">MS_BIND</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span> <span class="o">||</span>
          <span class="n">mount</span><span class="p">(</span><span class="s">&#34;conf/resolv.conf&#34;</span><span class="p">,</span> <span class="s">&#34;rootfs/etc/resolv.conf&#34;</span><span class="p">,</span> <span class="s">&#34;none&#34;</span><span class="p">,</span> <span class="n">MS_BIND</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;conf&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/* 模仿docker run命令中的 -v, --volume=[] 参数干的事 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mount</span><span class="p">(</span><span class="s">&#34;/tmp/t1&#34;</span><span class="p">,</span> <span class="s">&#34;rootfs/mnt&#34;</span><span class="p">,</span> <span class="s">&#34;none&#34;</span><span class="p">,</span> <span class="n">MS_BIND</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;mnt&#34;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* chroot 隔离目录 */</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">chdir</span><span class="p">(</span><span class="s">&#34;./rootfs&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">chroot</span><span class="p">(</span><span class="s">&#34;./&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">){</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;chdir/chroot&#34;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">execv</span><span class="p">(</span><span class="n">container_args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">container_args</span><span class="p">);</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">&#34;exec&#34;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Something&#39;s wrong!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Parent [%5d] - start a container!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
    <span class="kt">int</span> <span class="n">container_pid</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="n">container_main</span><span class="p">,</span> <span class="n">container_stack</span><span class="o">+</span><span class="n">STACK_SIZE</span><span class="p">,</span> 
            <span class="n">CLONE_NEWUTS</span> <span class="o">|</span> <span class="n">CLONE_NEWIPC</span> <span class="o">|</span> <span class="n">CLONE_NEWPID</span> <span class="o">|</span> <span class="n">CLONE_NEWNS</span> <span class="o">|</span> <span class="n">SIGCHLD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">waitpid</span><span class="p">(</span><span class="n">container_pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Parent - container stopped!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">&lt;/</span><span class="n">container_id</span><span class="o">&gt;&lt;/</span><span class="n">unistd</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;&lt;/</span><span class="n">signal</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;&lt;/</span><span class="n">sched</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;&lt;/</span><span class="n">stdio</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;&lt;/</span><span class="n">sys</span><span class="o">&gt;&lt;/</span><span class="n">sys</span><span class="o">&gt;&lt;/</span><span class="n">sys</span><span class="o">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>sudo运行上面的程序，你会看到下面的挂载信息以及一个所谓的“镜像”：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">derios@ubuntu:~$ sudo ./mount 
Parent <span class="o">[</span> 4517<span class="o">]</span> - start a container!
Container <span class="o">[</span>    1<span class="o">]</span> - inside the container!
root@container:/# mount
proc on /proc <span class="nb">type</span> proc <span class="o">(</span>rw,relatime<span class="o">)</span>
sysfs on /sys <span class="nb">type</span> sysfs <span class="o">(</span>rw,relatime<span class="o">)</span>
none on /tmp <span class="nb">type</span> tmpfs <span class="o">(</span>rw,relatime<span class="o">)</span>
udev on /dev <span class="nb">type</span> devtmpfs <span class="o">(</span>rw,relatime,size<span class="o">=</span>493976k,nr_inodes<span class="o">=</span>123494,mode<span class="o">=</span>755<span class="o">)</span>
devpts on /dev/pts <span class="nb">type</span> devpts <span class="o">(</span>rw,relatime,mode<span class="o">=</span>600,ptmxmode<span class="o">=</span>000<span class="o">)</span>
tmpfs on /run <span class="nb">type</span> tmpfs <span class="o">(</span>rw,relatime<span class="o">)</span>
/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hosts <span class="nb">type</span> ext4 <span class="o">(</span>rw,relatime,errors<span class="o">=</span>remount-ro,data<span class="o">=</span>ordered<span class="o">)</span>
/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hostname <span class="nb">type</span> ext4 <span class="o">(</span>rw,relatime,errors<span class="o">=</span>remount-ro,data<span class="o">=</span>ordered<span class="o">)</span>
/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/resolv.conf <span class="nb">type</span> ext4 <span class="o">(</span>rw,relatime,errors<span class="o">=</span>remount-ro,data<span class="o">=</span>ordered<span class="o">)</span>

root@container:/# ls /bin /usr/bin
/bin:
bash   chmod  <span class="nb">echo</span>  hostname  less  more  mv   ping  rm   sleep  tail  <span class="nb">test</span>    top   truncate  uname
cat    chown  grep  ip        ln    mount  nc   ps    sed  tabs   tar   timeout  touch  tty     which
chgrp  cp     gzip  <span class="nb">kill</span>      ls    mountpoint  netstat  <span class="nb">pwd</span>   sh   tac    tee   toe    tr   umount

/usr/bin:
awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs
</code></pre></td></tr></table>
</div>
</div><h2 id="user-namespace">User Namespace</h2>
<p>User Namespace 主要用到了<code>CLONE_NEWUSER</code>参数，当我们使用这个参数以后，在内部看到的UID和GID和外部就不一样了，默认为65534。因为容器找不到其真正的UID，因此设置成了最大的UID（<code>/proc/sys/kernel/overflowuid</code>）。</p>
<p>要把容器中的uid和真实系统的uid给映射在一起，需要修改 <strong>/proc/<pid>/uid_map</strong> 和 <strong>/proc/<pid>/gid_map</strong> 这两个文件。这两个文件的格式为：</p>
<p><code>ID-inside-ns ID-outside-ns length</code></p>
<ul>
<li>第一个字段ID-inside-ns表示在容器显示的UID或GID，</li>
<li>第二个字段ID-outside-ns表示容器外映射的真实的UID或GID。</li>
<li>第三个字段表示映射的范围，一般填1，表示一一对应。</li>
</ul>
<p>比如，把真实的uid=1000映射成容器内的uid=0</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ cat /proc/2465/uid_map
         <span class="m">0</span>       <span class="m">1000</span>          <span class="m">1</span>
</code></pre></td></tr></table>
</div>
</div><p>再比如下面的示例：表示把namespace内部从0开始的uid映射到外部从0开始的uid，其最大范围是无符号32位整形：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ cat /proc/<span class="nv">$$</span>/uid_map
         <span class="m">0</span>          <span class="m">0</span>          <span class="m">4294967295</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>写这两个文件的进程需要这个namespace中的CAP_SETUID (CAP_SETGID)权限（可参看<a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">Capabilities</a>）</li>
<li>写入的进程必须是此user namespace的父或子的user namespace进程。</li>
<li>另外需要满如下条件之一：1）父进程将effective uid/gid映射到子进程的user namespace中，2）父进程如果有CAP_SETUID/CAP_SETGID权限，那么它将可以映射到父进程中的任一uid/gid。</li>
</ul>
<p>User Namespace是以普通用户运行，但是别的Namespace需要root权限，那么，如果我要同时使用多个Namespace，该怎么办呢？一般来说，我们先用一般用户创建User Namespace，然后把这个一般用户映射成root，在容器内用root来创建其它的Namesapce。</p>
<h2 id="network-namespace">Network Namespace</h2>
<p>在linux中，一般用<code>ip</code>命令创建network namespace。不过在docker源码中并没有使用<code>ip</code>，而是自己实现了ip命令的一些内容。在这还是用<code>ip</code>命令描述一下做了啥。</p>
<p>首先我们来看一个图，这个图是Docker在host主机上的网络示意图</p>
<p><img src="https://coolshell.cn/wp-content/uploads/2015/04/network.namespace.jpg" alt="host network"></p>
<p>实际上图还是有问题的，因为Docker也可以运行在虚拟机中，所以所谓的物理网卡其实也就是一个有能够路由的IP的网卡。</p>
<p>图中Docker用了一个私有的网段: 172.40.1.0，此外docker还会使用10.0.0.0以及192.168.0.0两个私有网段。如果你机器的路由表配置了(占用)所有的私有网段，那么docker就会无法启动。</p>
<p>启动docker以后，可以使用<code>ip link show</code>和<code>ip addr show</code>来查看目前宿主机的网络情况。这里我在<code>minikube</code>容器里执行了指令:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">root@minikube:/# ip link show
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN mode DEFAULT group default qlen <span class="m">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: tunl0@NONE: &lt;NOARP&gt; mtu <span class="m">1480</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class="m">1000</span>
    link/ipip 0.0.0.0 brd 0.0.0.0
3: ip6tnl0@NONE: &lt;NOARP&gt; mtu <span class="m">1452</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class="m">1000</span>
    link/tunnel6 :: brd ::
4: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP mode DEFAULT group default
    link/ether 02:42:2e:11:a4:ae brd ff:ff:ff:ff:ff:ff
6: vetha68cfee@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master docker0 state UP mode DEFAULT group default
    link/ether 46:2d:cf:22:79:9f brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">1</span>
12: veth8b65072@if11: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master docker0 state UP mode DEFAULT group default
    link/ether 3e:fb:54:6d:ae:1e brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">3</span>
14: veth61918b0@if13: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master docker0 state UP mode DEFAULT group default
    link/ether d2:68:38:76:73:c9 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">4</span>
18: vethd7fa219@if17: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master docker0 state UP mode DEFAULT group default
    link/ether 1e:14:79:68:f1:50 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">5</span>
20: eth0@if21: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP mode DEFAULT group default
    link/ether 02:42:c0:a8:31:02 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">0</span>
21: veth3b477c9@if19: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master docker0 state UP mode DEFAULT group default
    link/ether 7e:b1:5d:53:00:ff brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">2</span>
23: veth265059d@if22: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master docker0 state UP mode DEFAULT group default
    link/ether 4a:22:a4:05:79:e1 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">6</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到有<code>docker0</code>还有一些虚拟网卡。</p>
<p>为了能够做成这样，我又google了一段代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1">## 首先，我们先增加一个网桥lxcbr0，模仿docker0</span>
brctl addbr lxcbr0
brctl stp lxcbr0 off
ifconfig lxcbr0 192.168.10.1/24 up <span class="c1">#为网桥设置IP地址</span>

<span class="c1">## 接下来，我们要创建一个network namespace - ns1</span>

<span class="c1"># 增加一个namesapce 命令为 ns1 （使用ip netns add命令）</span>
ip netns add ns1 

<span class="c1"># 激活namespace中的loopback，即127.0.0.1（使用ip netns exec ns1来操作ns1中的命令）</span>
ip netns <span class="nb">exec</span> ns1   ip link <span class="nb">set</span> dev lo up 

<span class="c1">## 然后，我们需要增加一对虚拟网卡</span>

<span class="c1"># 增加一个pair虚拟网卡，注意其中的veth类型，其中一个网卡要按进容器中</span>
ip link add veth-ns1 <span class="nb">type</span> veth peer name lxcbr0.1

<span class="c1"># 把 veth-ns1 按到namespace ns1中，这样容器中就会有一个新的网卡了</span>
ip link <span class="nb">set</span> veth-ns1 netns ns1

<span class="c1"># 把容器里的 veth-ns1改名为 eth0 （容器外会冲突，容器内就不会了）</span>
ip netns <span class="nb">exec</span> ns1  ip link <span class="nb">set</span> dev veth-ns1 name eth0 

<span class="c1"># 为容器中的网卡分配一个IP地址，并激活它</span>
ip netns <span class="nb">exec</span> ns1 ifconfig eth0 192.168.10.11/24 up


<span class="c1"># 上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上</span>
brctl addif lxcbr0 lxcbr0.1

<span class="c1"># 为容器增加一个路由规则，让容器可以访问外面的网络</span>
ip netns <span class="nb">exec</span> ns1     ip route add default via 192.168.10.1

<span class="c1"># 在/etc/netns下创建network namespce名称为ns1的目录，</span>
<span class="c1"># 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了</span>
mkdir -p /etc/netns/ns1
<span class="nb">echo</span> <span class="s2">&#34;nameserver 8.8.8.8&#34;</span> &gt; /etc/netns/ns1/resolv.conf
</code></pre></td></tr></table>
</div>
</div><p>上述就是docker网络的原理，但是有几点要注意的</p>
<ol>
<li>docker的resolv.conf（配置系统DNS解析器）没有采取这样的方式，而是采取类似上述<code>mount namespace</code>的方式</li>
<li>另外，docker采用进程的PID来做network namepspace的名称</li>
</ol>
<p>我们原理了解了，甚至可以给正在运行的docker容器新增网卡:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">ip link add peerA <span class="nb">type</span> veth peer name peerB 
brctl addif docker0 peerA 
ip link <span class="nb">set</span> peerA up 
ip link <span class="nb">set</span> peerB netns <span class="si">${</span><span class="nv">container</span><span class="p">-pid</span><span class="si">}</span> 
ip netns <span class="nb">exec</span> <span class="si">${</span><span class="nv">container</span><span class="p">-pid</span><span class="si">}</span> ip link <span class="nb">set</span> dev peerB name eth1 
ip netns <span class="nb">exec</span> <span class="si">${</span><span class="nv">container</span><span class="p">-pid</span><span class="si">}</span> ip link <span class="nb">set</span> eth1 up <span class="p">;</span> 
ip netns <span class="nb">exec</span> <span class="si">${</span><span class="nv">container</span><span class="p">-pid</span><span class="si">}</span> ip addr add <span class="si">${</span><span class="nv">ROUTEABLE_IP</span><span class="si">}</span> dev eth1 <span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>上述指令即为一个正在运行的docker容器新增一个<code>eth1</code>网卡，以及给了一个可以被外部访问到的IP静态IP地址。</p>
<p>这种做法，需要把外部的<code>物理网卡</code>设置为混杂模式(<a href="https://cloud.tencent.com/developer/article/1439013">Promiscuous Model</a>)，也就是网卡接受所有流过网卡的帧(数据包)，包括那些不是发给本机的包，不验证MAC地址。这样这个<code>eth1</code>网卡就会向外部通过<a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">ARP地址解析协议</a>发送自己的MAC地址，然后外部的交换机就会把这个IP地址的包转到<code>物理网卡</code>上。因为网卡工作在混杂模式，因此<code>eth1</code>就能收到相关的数据。如果发现是自己的数据，那么就接受，这样Docker容器的网络就与外部相通。</p>
<p>其实不管是Docker的NAT模式，还是混杂模式都会存在性能问题。NAT很明显转发(NAT转换)就有开销，而混杂模式下，网卡收到的负载都会完全交给所有的虚拟网卡，所以想想哪怕一个网卡没有数据，也会被其他网卡的数据影响。</p>
<p>因此这两种方式都不算完美，真正解决这样网络问题的是<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91">VLAN技术</a>。因此Google的开发者为linux内核实现了一个<a href="https://lwn.net/Articles/620087/">IPVLAN驱动</a>，基本为Docker量身定制。</p>
<h2 id="namespace文件">Namespace文件</h2>
<p>整理完了linux namespace的玩法，在看一下ns的文件。</p>
<p>我们再运行一遍PID Namepace篇章中的<code>pid.mnt</code>程序(mount proc)，然后不退出:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo ./pid.mnt 
<span class="o">[</span>sudo<span class="o">]</span> password <span class="k">for</span> derios: 
Parent <span class="o">[</span> 4599<span class="o">]</span> - start a container!
Container <span class="o">[</span>    1<span class="o">]</span> - inside the container!
</code></pre></td></tr></table>
</div>
</div><p>打开另外一个shell看一下父子进程的PID:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">derios@ubuntu:~$ pstree -p <span class="m">4599</span>
pid.mnt<span class="o">(</span>4599<span class="o">)</span>───bash<span class="o">(</span>4600<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以到proc下（/proc//ns）查看进程的各个namespace的id（内核版本需要3.8以上），下面是父进程的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">derios@ubuntu:~$ sudo ls -l /proc/4599/ns
total <span class="m">0</span>
lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span>  4月  <span class="m">7</span> 22:01 ipc -&gt; ipc:<span class="o">[</span>4026531839<span class="o">]</span>
lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span>  4月  <span class="m">7</span> 22:01 mnt -&gt; mnt:<span class="o">[</span>4026531840<span class="o">]</span>
lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span>  4月  <span class="m">7</span> 22:01 net -&gt; net:<span class="o">[</span>4026531956<span class="o">]</span>
lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span>  4月  <span class="m">7</span> 22:01 pid -&gt; pid:<span class="o">[</span>4026531836<span class="o">]</span>
lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span>  4月  <span class="m">7</span> 22:01 user -&gt; user:<span class="o">[</span>4026531837<span class="o">]</span>
lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span>  4月  <span class="m">7</span> 22:01 uts -&gt; uts:<span class="o">[</span>4026531838<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>下面是子进程的:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">derios@ubuntu:~$ sudo ls -l /proc/4600/ns
total <span class="m">0</span>
lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span>  4月  <span class="m">7</span> 22:01 ipc -&gt; ipc:<span class="o">[</span>4026531839<span class="o">]</span>
lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span>  4月  <span class="m">7</span> 22:01 mnt -&gt; mnt:<span class="o">[</span>4026532520<span class="o">]</span>
lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span>  4月  <span class="m">7</span> 22:01 net -&gt; net:<span class="o">[</span>4026531956<span class="o">]</span>
lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span>  4月  <span class="m">7</span> 22:01 pid -&gt; pid:<span class="o">[</span>4026532522<span class="o">]</span>
lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span>  4月  <span class="m">7</span> 22:01 user -&gt; user:<span class="o">[</span>4026531837<span class="o">]</span>
lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span>  4月  <span class="m">7</span> 22:01 uts -&gt; uts:<span class="o">[</span>4026532521<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>仔细看一下区别，发现ipc, net, user为相同ID，而mnt, pid, uts都不同。如果两个进程指向的namespace编号相同，则说明它俩在同一个namespace下，否则就不在。（如果读者你想验证，<code>docker exec -it &lt;container name&gt; bash</code>到一个容器里，top找两个进程，然后cat一下proc中对应PID的ns即可）</p>
<p>这些文件还有另一个作用，那就是，一旦这些文件被打开，只要其fd被占用着，那么就算PID所属的所有进程都已经结束，创建的namespace也会一直存在。比如：我们可以通过：mount –bind /proc/4600/ns/uts ~/uts 来hold这个namespace。</p>
<p>我们在最开始点了一下<code>setns</code>系统调用，函数声明如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">setns</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nstype</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>其中第一个参数就是一个fd，也就是一个open()系统调用打开了上述文件后返回的fd，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">&#34;/proc/4600/ns/nts&#34;</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>  <span class="c1">// 获取namespace文件描述符
</span><span class="c1"></span><span class="n">setns</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 加入新的namespace
</span></code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">CctoctoFX</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2021-04-01
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/docker/">docker</a>
          <a href="/tags/cloud-computing/">cloud-computing</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/cloud-computing/docker-cgroup/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Docker Fundamentals: Cgroup</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/cloud-computing/k8s-basic/">
            <span class="next-text nav-default">Kubernetes Handbook (Start &amp; Pod)</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="derios1230@email.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/pillumina" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/fang-xian-20" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="http://localhost:2000/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>CctoctoFX</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>








</body>
</html>
